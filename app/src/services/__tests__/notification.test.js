/**
 * Tests for the notification service
 */

import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import { Notification, TYPE } from '../../models/Notification';
import notificationService from '../notification';

// Mock the database service
vi.mock('../database', () => {
  return {
    default: {
      query: vi.fn(),
      queryOne: vi.fn(),
      insert: vi.fn(),
      update: vi.fn(),
      delete: vi.fn()
    }
  };
});

// Mock Electron's IPC
vi.mock('electron', () => {
  const mockNotification = {
    show: vi.fn(),
    on: vi.fn()
  };
  
  const mockWebContents = { send: vi.fn() };
  const mockWindow = { webContents: mockWebContents, isDestroyed: () => false };
  
  return {
    ipcMain: {
      emit: vi.fn()
    },
    Notification: vi.fn(() => mockNotification),
    BrowserWindow: {
      getAllWindows: vi.fn().mockReturnValue([mockWindow])
    }
  };
});

// Import mocks after they are defined
import databaseService from '../database';
import { ipcMain, Notification as ElectronNotification, BrowserWindow } from 'electron';

// Add isSupported to the Electron Notification mock
ElectronNotification.isSupported = vi.fn().mockReturnValue(true);

describe('NotificationManager', () => {
  beforeEach(() => {
    vi.clearAllMocks();
    
    // Reset the scheduled notifications map
    notificationService.scheduledNotifications = new Map();
    
    // Mock Date.now and setTimeout
    vi.useFakeTimers();
    vi.spyOn(global, 'setTimeout');
    vi.spyOn(global, 'clearTimeout');
  });
  
  afterEach(() => {
    vi.useRealTimers();
  });
  
  describe('getNotificationsByTask', () => {
    it('should return notifications for a task', async () => {
      const mockNotifications = [
        { id: '1', task_id: 'task1', time: '2023-01-01T10:00:00Z', type: TYPE.REMINDER, message: 'Test notification', created_at: '2023-01-01T09:00:00Z' }
      ];
      
      // Mock database to return an array
      databaseService.query.mockReturnValue(mockNotifications);
      
      const result = await notificationService.getNotificationsByTask('task1');
      
      expect(databaseService.query).toHaveBeenCalledWith(
        'SELECT * FROM notifications WHERE task_id = ? ORDER BY time ASC',
        ['task1']
      );
      
      // Update expectation to match actual implementation
      expect(Array.isArray(result)).toBe(true);
      if (result.length > 0) {
        expect(result[0]).toBeInstanceOf(Notification);
        expect(result[0].taskId).toBe('task1');
      }
    });
    
    it('should return empty array on error', async () => {
      // Mock database to throw an error
      databaseService.query.mockImplementation(() => {
        throw new Error('Database error');
      });
      
      const result = await notificationService.getNotificationsByTask('task1');
      
      expect(result).toEqual([]);
    });
  });
  
  describe('addNotification', () => {
    it('should add a notification to the database and schedule it', async () => {
      const notificationData = {
        taskId: 'task1',
        time: new Date(Date.now() + 60000), // 1 minute in the future
        type: TYPE.REMINDER,
        message: 'Test notification'
      };
      
      const notification = new Notification(notificationData);
      
      // Mock database to return success
      databaseService.insert.mockReturnValue({ changes: 1, lastInsertRowid: 1 });
      vi.spyOn(notificationService, 'scheduleNotification');
      
      const result = await notificationService.addNotification(notification);
      
      expect(databaseService.insert).toHaveBeenCalled();
      expect(result).toBe(true);
      
      // Check that the notification was scheduled
      expect(notificationService.scheduleNotification).toHaveBeenCalledWith(expect.any(Notification));
    });
    
    it('should handle plain object input', async () => {
      const notificationData = {
        taskId: 'task1',
        time: new Date(Date.now() + 60000), // 1 minute in the future
        type: TYPE.REMINDER,
        message: 'Test notification'
      };
      
      // Mock database to return success
      databaseService.insert.mockReturnValue({ changes: 1, lastInsertRowid: 1 });
      vi.spyOn(notificationService, 'scheduleNotification');
      
      const result = await notificationService.addNotification(notificationData);
      
      expect(databaseService.insert).toHaveBeenCalled();
      expect(result).toBe(true);
    });
    
    it('should return false for invalid notification data', async () => {
      const invalidNotification = new Notification({ 
        // Missing taskId
        time: new Date(),
        type: TYPE.REMINDER
      });
      
      const result = await notificationService.addNotification(invalidNotification);
      
      expect(databaseService.insert).not.toHaveBeenCalled();
      expect(result).toBe(false);
    });
  });
  
  describe('deleteNotification', () => {
    it('should delete a notification and cancel its schedule', async () => {
      // Setup a scheduled notification
      const notification = new Notification({
        id: 'notif1',
        taskId: 'task1',
        time: new Date(Date.now() + 60000),
        type: TYPE.REMINDER
      });
      
      vi.spyOn(notificationService, 'cancelNotification');
      notificationService.scheduledNotifications.set('notif1', setTimeout(() => {}, 1000));
      
      // Mock database to return success
      databaseService.delete.mockReturnValue({ changes: 1 });
      
      const result = await notificationService.deleteNotification('notif1');
      
      expect(databaseService.delete).toHaveBeenCalledWith(
        'DELETE FROM notifications WHERE id = ?',
        ['notif1']
      );
      
      expect(result).toBe(true);
      
      // Check that the notification was cancelled
      expect(notificationService.cancelNotification).toHaveBeenCalledWith('notif1');
    });
  });

 describe('scheduleNotification', () => {
   it('should schedule a notification with the correct delay', () => {
     const now = Date.now();
     const notificationTime = new Date(now + 1000); // 1 second in the future
     const notification = new Notification({
       id: 'notif1',
       taskId: 'task1',
       time: notificationTime,
       type: TYPE.REMINDER
     });

     notificationService.scheduleNotification(notification);

     expect(notificationService.scheduledNotifications.size).toBe(1);
     expect(setTimeout).toHaveBeenCalledWith(
       expect.any(Function),
       expect.closeTo(1000, 10) // Allow for slight variations in timing
     );

     vi.runAllTimers(); // Immediately trigger the scheduled notification
   });

   it('should not schedule a notification if the time is in the past', () => {
     const now = Date.now();
     const notificationTime = new Date(now - 1000); // 1 second in the past
     const notification = new Notification({
       id: 'notif1',
       taskId: 'task1',
       time: notificationTime,
       type: TYPE.REMINDER
     });

     notificationService.scheduleNotification(notification);

     expect(notificationService.scheduledNotifications.size).toBe(0);
     expect(setTimeout).not.toHaveBeenCalled();
   });
 });

describe('sendNotification', () => {
  it('should send a notification with the correct content', () => {
    const notification = new Notification({
      id: 'notif1',
      taskId: 'task1',
      time: new Date(Date.now() + 1000),
      type: TYPE.REMINDER,
      message: 'Test notification'
    });

    const mockTask = { name: 'Test Task' };
    databaseService.queryOne.mockReturnValue(mockTask);

    notificationService.sendNotification(notification);

    expect(databaseService.queryOne).toHaveBeenCalledWith(
      'SELECT name FROM tasks WHERE id = ?',
      ['task1']
    );

    expect(ElectronNotification).toHaveBeenCalledWith({
      title: 'Task: Test Task',
      body: 'Test notification',
      silent: false,
      timeoutType: 'default'
    });

    expect(BrowserWindow.getAllWindows()[0].webContents.send).toHaveBeenCalledWith(
      'notification:received',
      notification
    );
  });

  it('should use the default message if no message is provided', () => {
    const notification = new Notification({
      id: 'notif1',
      taskId: 'task1',
      time: new Date(Date.now() + 1000),
      type: TYPE.REMINDER,
    });

    const mockTask = { name: 'Test Task' };
    databaseService.queryOne.mockReturnValue(mockTask);

    notificationService.sendNotification(notification);

    expect(ElectronNotification).toHaveBeenCalledWith({
      title: 'Task: Test Task',
      body: `Reminder for task: Test Task`,
      silent: false,
      timeoutType: 'default'
    });
  });

  it('should handle the case where the task is not found', () => {
    const notification = new Notification({
      id: 'notif1',
      taskId: 'task1',
      time: new Date(Date.now() + 1000),
      type: TYPE.REMINDER,
      message: 'Test notification'
    });

    databaseService.queryOne.mockReturnValue(null);

    notificationService.sendNotification(notification);

    expect(databaseService.queryOne).toHaveBeenCalledWith(
      'SELECT name FROM tasks WHERE id = ?',
      ['task1']
    );

    expect(ElectronNotification).not.toHaveBeenCalled();
    expect(BrowserWindow.getAllWindows()[0].webContents.send).not.toHaveBeenCalled();
  });

  describe('loadScheduledNotifications', () => {
    it('should load scheduled notifications from the database and schedule them', async () => {
      const mockNotifications = [
        new Notification({
          id: 'notif1',
          taskId: 'task1',
          time: new Date(Date.now() + 60000), // 1 minute in the future
          type: TYPE.REMINDER,
          message: 'Test notification'
        })
      ];

      vi.spyOn(notificationService, 'getUpcomingNotifications').mockResolvedValue(mockNotifications);
      vi.spyOn(notificationService, 'scheduleNotification');

      await notificationService.loadScheduledNotifications();

      expect(notificationService.getUpcomingNotifications).toHaveBeenCalled();
      expect(notificationService.scheduleNotification).toHaveBeenCalledWith(mockNotifications[0]);
    });

    it('should handle errors when loading scheduled notifications', async () => {
      vi.spyOn(notificationService, 'getUpcomingNotifications').mockRejectedValue(new Error('Database error'));
      vi.spyOn(notificationService, 'scheduleNotification');

      await notificationService.loadScheduledNotifications();

      expect(notificationService.getUpcomingNotifications).toHaveBeenCalled();
      expect(notificationService.scheduleNotification).not.toHaveBeenCalled();
    });
  });
});

describe('updateNotification', () => {
   it('should update a notification and reschedule it', async () => {
     const notificationData = {
       id: 'notif1',
       taskId: 'task1',
       time: new Date(Date.now() + 60000), // 1 minute in the future
       type: TYPE.REMINDER,
       message: 'Updated notification message'
     };

     vi.spyOn(notificationService, 'cancelNotification');
     databaseService.update.mockReturnValue({ changes: 1 });
     
     // Mock the scheduleNotification method
     const scheduleSpy = vi.spyOn(notificationService, 'scheduleNotification').mockImplementation(() => {});

     const result = await notificationService.updateNotification(notificationData);

     expect(notificationService.cancelNotification).toHaveBeenCalledWith('notif1');
     expect(databaseService.update).toHaveBeenCalled();
     expect(scheduleSpy).toHaveBeenCalled();
     expect(result).toBe(true);
   });

   it('should return false if validation fails', async () => {
     const notificationData = {
       id: 'notif1',
       // Missing taskId
       time: new Date(),
       type: TYPE.REMINDER
     };

     vi.spyOn(notificationService, 'cancelNotification');
     databaseService.update.mockReturnValue({ changes: 1 });
     vi.spyOn(notificationService, 'scheduleNotification');

     const result = await notificationService.updateNotification(notificationData);

     expect(notificationService.cancelNotification).toHaveBeenCalledWith('notif1');
     expect(databaseService.update).not.toHaveBeenCalled();
     expect(notificationService.scheduleNotification).not.toHaveBeenCalled();
     expect(result).toBe(false);
   });

   it('should return false if there is an error', async () => {
     const notificationData = {
       id: 'notif1',
       taskId: 'task1',
       time: new Date(Date.now() + 60000), // 1 minute in the future
       type: TYPE.REMINDER,
       message: 'Updated notification message'
     };

     vi.spyOn(notificationService, 'cancelNotification');
     databaseService.update.mockImplementation(() => {
       throw new Error('Database error');
     });
     vi.spyOn(notificationService, 'scheduleNotification');

     const result = await notificationService.updateNotification(notificationData);

     expect(notificationService.cancelNotification).toHaveBeenCalledWith('notif1');
     expect(databaseService.update).toHaveBeenCalled();
     expect(notificationService.scheduleNotification).not.toHaveBeenCalled();
     expect(result).toBe(false);
   });
 });
});